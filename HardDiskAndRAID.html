<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
先来扯淡吧，圣诞节前几天一直在看一些论文，磁盘相关的，今天索性一次性写完，不然看了又忘记了。  
##1. 硬盘
　　硬盘的基础知识就不赘述了，什么磁头磁道扇区等等啦，看下图一目了然，不了然的话自己看书去。  

　　　　![磁盘](http://7te99v.com1.z0.glb.clouddn.com/@/blog/testsectors-and-clusters1.png)    
　　然后有一点需要明确一下，那就是磁盘保证对于扇区的更新操作都是**原子**的。每次写扇区要么全写进去了要么全没写进去。  
　　下面写一些磁盘的调度算法吧。调度嘛，就是说如果有多个请求，磁盘怎么依次处理这些请求。有一个大的准则，持续时间短的请求先执行(**shortest job first**)，这个也很好理解，毕竟使得所有请求的平均等待时间最小。但是，这个很难做到，因为很难预先知道一个请求执行所需要的时间。于是乎就有了下面的近似算法了:

1. **Shortest Seek Time First(SSTF)**  
　　这个就是，下一次执行的磁盘命令是选择最近磁道上的请求命令，但是这个也很难做到，因为操作系统根本看不见磁道啊，它也不知道磁盘的空间几何分布，所以实际上有个替代的，**nearst-block-first(NBF)**，物理地址最相近的最先执行。  
　　听起来这个**NBF调度**应该是不错的，但是有一个特殊情况，就是说距离当前磁头位置比较远的那个磁盘请求可能“永远”也没法被调度到。这就是调度中经常需要考虑的“饥饿”问题。  


2. **Elevator**  
　　这就是升降机算法了。将当前所有的磁盘请求命令按照**NBF**调度依次执行，执行过程中收到的磁盘请求暂时不处理。这就解决了上面的饥饿问题了。

3. **Shortest Positioning Time First**
　　这个呢，是考虑到了实际的磁盘寻址时间，因为你物理地址相近不代表磁头寻址所需时间短，还得考虑一个磁盘转向问题

<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<p>先来扯淡吧，圣诞节前几天一直在看一些论文，磁盘相关的，今天索性一次性写完，不然看了又忘记了。  </p>

<h2 id="1">1. 硬盘</h2>

<p>　　硬盘的基础知识就不赘述了，什么磁头磁道扇区等等啦，看下图一目了然，不了然的话自己看书去。  </p>

<p>　　　　<img src="http://7te99v.com1.z0.glb.clouddn.com/@/blog/testsectors-and-clusters1.png" alt="磁盘" title=""> <br>
　　然后有一点需要明确一下，那就是磁盘保证对于扇区的更新操作都是<strong>原子</strong>的。每次写扇区要么全写进去了要么全没写进去。 <br>
　　下面写一些磁盘的调度算法吧。调度嘛，就是说如果有多个请求，磁盘怎么依次处理这些请求。有一个大的准则，持续时间短的请求先执行(<strong>shortest job first</strong>)，这个也很好理解，毕竟使得所有请求的平均等待时间最小。但是，这个很难做到，因为很难预先知道一个请求执行所需要的时间。于是乎就有了下面的近似算法了:</p>

<ol>
<li><p><strong>Shortest Seek Time First(SSTF)</strong> <br>
　　这个就是，下一次执行的磁盘命令是选择最近磁道上的请求命令，但是这个也很难做到，因为操作系统根本看不见磁道啊，它也不知道磁盘的空间几何分布，所以实际上有个替代的，<strong>nearst-block-first(NBF)</strong>，物理地址最相近的最先执行。 <br>
　　听起来这个<strong>NBF调度</strong>应该是不错的，但是有一个特殊情况，就是说距离当前磁头位置比较远的那个磁盘请求可能“永远”也没法被调度到。这就是调度中经常需要考虑的“饥饿”问题。  </p></li>
<li><p><strong>Elevator</strong> <br>
　　这就是升降机算法了。将当前所有的磁盘请求命令按照<strong>NBF</strong>调度依次执行，执行过程中收到的磁盘请求暂时不处理。这就解决了上面的饥饿问题了。</p></li>
<li><p><strong>Shortest Positioning Time First</strong>
　　这个呢，是考虑到了实际的磁盘寻址时间，因为你物理地址相近不代表磁头寻址所需时间短，还得考虑一个磁盘转向问题</p></li>
</ol>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "HardDiskAndRAID.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
</body>
</html>
